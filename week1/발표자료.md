# CoroutineScope

> 코루틴이 실행될 수 있는 “범위” 또는 “영역”을 정의
> 
> → 코루틴은 혼자 실행되지 않고 항상 특정 `CoroutineScope` 안에서 실행됨
> 
> → 이 스코프는 새로 시작된 코루틴을 추적하고 관리하는 역할을 함


## 핵심 역할

가장 중요한 역할은 코루틴의 생명주기(Lifecycle)를 관리하는 것

1. 코루틴 추적: 스코프 내에서 `launch`나 `async`를 사용해 코루틴을 시작하면, 해당 스코프는 이 코루틴을 ‘자식’으로 등록하고 추적
    - `launch` 와 `async` 의 차이 → 4주차
2. 동시 취소(Structured Concurrency): 스코프가 취소되면, 그 안에서 실행 중이던 모든 자식 코루틴도 함께 취소됨

→ “구조화된 동시성(Structured concurrency)”의 핵심

→ 코루틴이 무한정 실행되어 발생하는 메모리 릭(memory leak)이나 리소스 낭비를 방지할 수 있음

## CoroutineScope의 구성 요소

- CoroutineScope는 `CoroutineContext`라는 중요한 정보를 가지고 있음
- `CoroutineContext`는 코루틴이 어떻게 동작할지 정의하는 설정값들의 묶음 → 3주차
- 주로 다음 두 가지를 포함
    - `Job` (작업) : 코루틴의 생명주기(시작, 실행 중, 취소, 완료)를 제어
        - 스코프가 취소될 때 모든 자식 `Job`을 취소시킴
    - `Dispatcher` (디스패처) : 코루틴을 어떤 스레드에서 실행할지 결정
        - `Dispatcher.Main` : 안드로이드의 메인 UI 스레드
        - `Dispatchers.IO` : 네트워크 통신이나 파일 입출력 같은 작업에 최적화된 스레드
        - `Dispatchers.Default` : CPU를 많이 사용하는 복잡한 연산에 적합한 스레드

## 자주 사용하는 CoroutineScope 예시

안드로이드 개발에서는 이미 생명주기에 맞게 미리 정의된 스코프를 주로 사용

- `viewModelScope`
    - ViewModel 내에서 사용하는 스코프
    - ViewModel이 파괴될 때(메모리에서 해제될 때) `viewModelScope` 도 자동으로 취소 → 실행 중이던 모든 네트워크 요청이나 DB 작업이 정리됨
    
    ```kotlin
    class MyViewModel : ViewModel() {
          fun fetchData() {
              // viewModelScope 안에서 코루틴 실행
              viewModelScope.launch(Dispatchers.IO) {
                  // 이 작업은 ViewModel이 살아있는 동안에만 유효함
                  val data = repository.getData()
              }
          }
      }
    ```
    
- `lifecycleScope`
    - Activity나 Fragment 같은 UI 컨트롤러에서 사용
    - 해당 컴포넌트의 생명주기(예: `onDestory`)에 맞춰 자동으로 취소됨
    
    ```kotlin
    class MyActivity : AppCompatActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
    
              // lifecycleScope 안에서 코루틴 실행
              lifecycleScope.launch {
                  // 이 작업은 Activity가 파괴되면 자동으로 취소됨
                  delay(10000)
              }
          }
      }
    ```
    
- `GlobalScope` (사용 비권장)
    - 애플리케이션의 전체 생명주기와 연결된 전역 스코프
    - 앱이 종료될 때까지 취소되지 않기 때문에, 특정 생명주기와 연결되지 않은 작업이 메모리 릭을 유발하기 쉬워 사용이 권장되지 않음

## 코루틴 빌더(Coroutine Builder)

가장 큰 차이점은 결과값을 반환하는가?

- `launch` : 코루틴을 시작하지만 결과값을 반환하지 않음
- `async`: 코루틴을 시작하고 결과값을 반환 (`Deferred` 객체를 통해 나중에 결과값을 받을 수 있음)

### launch (결과값이 필요 없는 작업)

“실행하고 잊어버리는” 방식의 작업

- 반환 값: `Job` 객체를 반환
- `Job`의 역할: 이 `Job` 객체를 통해 코루틴을 취소(`cancel()`)하거나, 코루틴이 끝날 때까지 기다릴(`join()`) 수 있음
- 하지만 결과값을 가져올 수는 없음
- 주요 사용
    - UI 업데이트
    - 백그라운드에서 데이터 저장 (결과가 당장 필요 없을 때)
    - 로그 전송

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job: Job = launch { // launch는 Job을 반환
        delay(1000L)
        println("World!")
    }

    println("Hello,")
    // job.join() // 이 줄의 주석을 풀면 "World!"가 출력될 때까지 기다림
}

/*
출력:
Hello,
(1초 후)
World!
*/
```

### async (결과값이 필요한 작업)

어떤 작업을 비동기적으로 사용하고, 그 결과를 나중에 사용할 때 사용

- 반환 값: `Deferred<T>` 객체를 반환 → 2주차
- `Defereed`의 역할: `Defereed`는 `Job`을 상속받기 때문에 `Job`이 할 수 있는 일(취소 등)을 모두 할 수 있으며, 결과값을 가지고 있음
- 결과 얻기: `.await()` 라는 `suspend` 함수를 호출하여 실제 결과값을 가져올 수 있음
    - `.await()`를 호출하면 `async` 블록이 완료될 때까지 현재 코루틴이 일시 중단(suspend) 됨
- 주요 사용
    - 네트워크 API 호출
    - 데이터베이스 조회
    - 복잡한 연산 수행 후 결과 반환
    
    ```kotlin
    import kotlinx.coroutines.*
    
    fun main() = runBlocking {
        val deferred: Deferred<String> = async { // async는 Deferred<String>을 반환
            delay(1000L)
            "World!" // "World!"라는 String 값을 반환
        }
    
        println("Hello,")
        
        val result = deferred.await() // 결과가 올 때까지 여기서 기다림
        println(result)
    }
    
    /*
    출력:
    Hello,
    (1초 후)
    World!
    */
    ```
    
    - 여러 작업을 동시에 실행하고 그 결과들을 조합할 때 사용
    
    ```kotlin
    import kotlinx.coroutines.*
    import kotlin.system.measureTimeMillis
    
    suspend fun fetchUser(id: Int): String {
        delay(1000L) // 1초가 걸리는 네트워크 요청 시뮬레이션
        return "User $id"
    }
    
    fun main() = runBlocking {
        val time = measureTimeMillis {
            // 두 개의 async 작업을 '동시에' 시작
            val user1: Deferred<String> = async { fetchUser(1) }
            val user2: Deferred<String> = async { fetchUser(2) }
    
            // 두 작업이 모두 끝날 때까지 기다렸다가 결과를 조합
            println("${user1.await()} and ${user2.await()}")
        }
        
        println("Total time: ${time}ms")
    }
    
    /*
    출력:
    (1초 후)
    User 1 and User 2
    Total time: 1018ms (약 1초. 2초가 아님!)
    */
    ```
    
    - ex. 1번 사용자와 2번 사용자 정보를 동시에 가져와야 할 때

### runBlocking

현재 스레드를 차단(Block)하는 코루틴 빌더

- 일반적인 코루틴 빌더(`launch`, `async`)는 코루틴을 시작시키고 바로 다음 코드로 넘어가지만, `runBlocking`은 자신의 블록 안에 있는 모든 코루틴이 완료될 때까지 현재 스레드를 멈춰 세움
- 핵심 특징
    - 스레드 차단 (Blocking)
        - `runBlocking`을 호출한 스레드는 `runBlocking` 블록 안의 코드가 모두 끝날 때까지 정지
        - `launch`나 `async`가 스레드를 차단하지 않고 '일시 중단(Suspending)'하는 것과는 정반대의 동작
    - 코루틴으로 연결
        - `runBlocking`은 코루틴이 아닌 일반 코드(non-coroutine world)에서 `suspend` 함수(coroutine world)를 호출해야 할 때 사용되는 연결 통로
        - `suspend` 함수는 다른 `suspend` 함수나 코루틴 스코프 내에서만 호출할 수 있는데, `runBlocking`이 바로 그 '스코프' 역할을 해줌
    - 반환 값
        - `runBlocking` 블록의 마지막 표현식(expression)이 반환 값이 반한됨
- 주요 사용
    - 비동기 코드를 실행하고 그 결과를 기다려야 할 때
    - 유닛 테스트에서 `suspend` 함수를 테스트할 때, 테스크 코드가 비동기 작업이 끝날 때까지 기다리도록 만들 때
- 안드로이드 메인 스레드에서는 ANR(Application Not Responding) 오류 발생하므로 사용하면 안됨
- 이미 코루틴 내부(`viewModelScope`, `lifecycleScope` 또는 다른 `suspend` 함수 내부)일 때는 쓸 이유가 없음
    - 이미 코루틴 환경이므로 `launch`, `async`, `withContext` 등을 사용해야 함